# -*- coding: utf-8 -*-
"""PCA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1I9XEOKdHWUzXXtmHM1hjvbZzq162lv5i
"""

'''
resources: https://www.statisticshowto.com/sensitivity-vs-specificity-statistics/

https://en.wikipedia.org/wiki/Precision_and_recall#Precision

https://builtin.com/data-science/step-step-explanation-principal-component-analysis

https://jakevdp.github.io/PythonDataScienceHandbook/05.09-principal-component-analysis.html

https://towardsdatascience.com/pca-using-python-scikit-learn-e653f8989e60

https://gerardnico.com/data_mining/pca

https://github.com/WillKoehrsen/feature-selector/blob/master/Feature%20Selector%20Development.ipynb

https://towardsdatascience.com/a-feature-selection-tool-for-machine-learning-in-python-b64dd23710f0

https://towardsdatascience.com/churn-prediction-3a4a36c2129a

https://realpython.com/logistic-regression-python/

https://medium.com/@thevie/fighting-telco-customer-churn-problem-a-data-driven-analysis-e7c61cfae0dd

https://towardsdatascience.com/churn-prediction-770d6cb582a5

RFE: https://towardsdatascience.com/predict-employee-turnover-with-python-da4975588aa3

https://medium.com/@thevie/fighting-telco-customer-churn-problem-a-data-driven-analysis-e7c61cfae0dd
'''

# Commented out IPython magic to ensure Python compatibility.
#Import the library
import pandas as pd
import numpy as np
import sklearn
import matplotlib.pyplot as plt
import seaborn as sns
# %matplotlib inline

#Load the data set
from google.colab import files
uploaded = files.upload()

#Load the data into the data frame
df = pd.read_csv('WA_Fn-UseC_-Telco-Customer-Churn.csv')

df[df.TotalCharges == ' ']



#Note Churn = 0 = No, Churn = Yes = 1
df.head()

df[df.Churn == 'Yes'].shape

df[df.Churn == 'No'].shape

#Transform non-numeric columns into numerical columns
from sklearn.preprocessing import LabelEncoder
conv_df = df

for column in conv_df.columns:
        if conv_df[column].dtype == np.number:
            continue
        conv_df[column] = LabelEncoder().fit_transform(conv_df[column])

cleaned_data = conv_df

#Show the first 5 rows of the new data set
cleaned_data.head()

#Scale the cleaned data
from sklearn.preprocessing import StandardScaler

X = cleaned_data.drop('Churn', axis = 1)
y = cleaned_data['Churn']

# Standardizing/scaling the features
X = StandardScaler().fit_transform(X)

'''
To determine which features or services discriminate retained cutomers from churned customers, 
I will create histograms of three features (MonthlyCharges, TotalCharges, and tenure ). From the image I 
can see that a high proportion of retained customers have a monthly charge between $20 and $30. , 
while the majority of churned customers had a monthly charge between $50 and $100 . 

I would expect the total charges to be heavily skewed to the left since most customers have a lower monthly charge, but I
can't truly see any discrimination from the total charges plot. 

The tenure histogram is heavily skewed towards the left for customers that churned and heavily skewed towards the right for customers 
that were retained. We can observe that the greater the tenure, the less chance of a customer churning.


'''
import matplotlib.pyplot as plt 
plt.style.use('fivethirtyeight')

numerical_features = ['tenure', 'MonthlyCharges', 'TotalCharges']
fig, ax = plt.subplots(1, 3, figsize=(28, 8))
cleaned_data[cleaned_data.Churn == 0][numerical_features].hist(bins=20, color="blue", alpha=0.5, ax=ax)
cleaned_data[cleaned_data.Churn == 1][numerical_features].hist(bins=20, color="red", alpha=0.5, ax=ax)

#PCA
from sklearn.decomposition import PCA
pca = PCA(n_components=3) #Reduce the dimensionality to 3
principalComponents = pca.fit_transform(X)

principalComponents

#Here, we can see that about 79.6% of the total variance comes from the first 2 components
ex_variance=np.var(principalComponents,axis=0)
ex_variance_ratio = ex_variance/np.sum(ex_variance)
print(ex_variance_ratio )

#PCA
from sklearn.decomposition import PCA
pca = PCA(n_components=2) #Reduce the dimensionality to 2
principalComponents = pca.fit_transform(X)

principalDf = pd.DataFrame(data = principalComponents
             , columns = ['principal component 1', 'principal component 2'])

finalDf = pd.concat([principalDf, df[['Churn']]], axis = 1)
finalDf

"""
Now, since the PCA components are orthogonal to each other and they are not 
correlated, we can expect to see Churn and Retained (Not Churned) classes distinctly.
Below is a plot of customer churn based on the first 2 principal components of the feature data
"""
import matplotlib.pyplot as plt
import seaborn as sns
plt.figure(figsize = (25, 12))
sns.scatterplot("principal component 1", "principal component 2", data = finalDf, hue ='Churn' )

import matplotlib.pyplot as plt 
plt.style.use('fivethirtyeight')

plt.figure(figsize = (25, 12))

projected = principalComponents
num_seq = range(0, X.shape[0])
plt.scatter(projected[:, 0], projected[:, 1],
             edgecolor='none', alpha=0.5, c=num_seq,
            cmap=plt.cm.get_cmap('Accent', 10))
plt.xlabel('component 1')
plt.ylabel('component 2')
plt.colorbar();

#Here, we can see that 100% of the total variance comes from these 2 components
ex_variance=np.var(principalComponents,axis=0)
ex_variance_ratio = ex_variance/np.sum(ex_variance)
print(ex_variance_ratio )

principalComponents

"""
Now, since the PCA components are orthogonal to each other and they are not 
correlated, we can expect to see Churn and Retained (Not Churn) classes distinctly.
Below is a plot of customer churn based on the first 2 principal components of the feature data
"""

Xax=principalComponents[:,0]
Yax=principalComponents[:,1]
labels=df['Churn']
cdict={0:'red',1:'blue'}
labl={0:'Retained',1:'Churned'}
marker={0:'*',1:'o'}
alpha={0:.3, 1:.5}
fig,ax=plt.subplots(figsize=(7,5))
fig.patch.set_facecolor('white')
for l in np.unique(labels):
 ix=np.where(labels==l)
 ax.scatter(Xax[ix],Yax[ix],c=cdict[l],s=40,
           label=labl[l],marker=marker[l],alpha=alpha[l])
# for loop ends
plt.xlabel("First Principal Component",fontsize=14)
plt.ylabel("Second Principal Component",fontsize=14)
plt.legend()
plt.show()
# please check the scatter plot of the remaining component and you will understand the difference

from sklearn.model_selection import train_test_split


#Split the data into 80% training and 20% testing
x_train, x_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

x_train.shape

# Make an instance of the Model / Choose the minimum number of principal components such that 95% of the variance is retained
from sklearn.decomposition import PCA
pca = PCA(.95)

#Fit PCA on training set
pca.fit(x_train)

pca.n_components_

#Apply the mapping (transform) to both the training set and the test set.
x_train = pca.transform(x_train)
x_test = pca.transform(x_test)

x_train.shape

x_train

from sklearn.linear_model import LogisticRegression
#Train the model
model = LogisticRegression()
model.fit(x_train, y_train) #Training the model

x_train.shape[1]

#recursive feature elimination
from sklearn.feature_selection import RFE

logreg = LogisticRegression()
rfe = RFE(logreg, x_train.shape[1])
rfe = rfe.fit(x_train,y_train)
print(rfe.support_)
print(rfe.ranking_)

from sklearn.metrics import classification_report
from sklearn.metrics import accuracy_score

predictions = model.predict(x_test)
print(predictions)# printing predictions

print()# Printing new line

#Check precision, recall, f1-score
print( classification_report(y_test, predictions) )

print( accuracy_score(y_test, predictions))

import numpy as np
y_test_array = np.asarray(y_test)

num_retained = 0
num_churned =0
#Note: Churn = No = 0, Churn = Yes = 1
for i in range(0,len(y_test_array)):
  if y_test_array[i] == 0:
    num_retained = num_retained + 1
  else:
    num_churned = num_churned + 1

print("The number of retained customers in the test data set: ",num_retained)
print("The number of churned customers in the test data set: ", num_churned)

print("Guessing that all customers will be retained accuracy score : ", num_retained/(num_retained+num_churned) )

#From the confusion matrix we can see that the logistic regression model predicted:
#1. True Positive = 941  (a predicted positive result that was actually positive)
#2. True Negative = 201 (a predicted negative result that was actually negative)
#3. False Positive = 172  (a predicted positive result that was actually negative)
#4. False Negative = 95 (a predicted negative result that was actually positive)
from sklearn.metrics import confusion_matrix
confusion_matrix(y_test, predictions)

# Get the confusion matrix (TP, FP, FN, & TN)
from sklearn.metrics import confusion_matrix
cm = confusion_matrix(y_test, predictions)
TP = cm[0][0]
FN = cm[0][1]
FP = cm[1][0]
TN = cm[1][1]
#Compute the miss rate 
miss_rate = FN / (FN + TP)

print('The miss rate:', miss_rate)

# Get the confusion matrix (TP, FP, FN, & TN)
from sklearn.metrics import confusion_matrix
cm = confusion_matrix(y_test, predictions)
TP = cm[0][0]
FN = cm[0][1]
FP = cm[1][0]
TN = cm[1][1]
#Compute the specificity 
specificity = TN / (TN + FP)

print('The specificity:', specificity)